import os
import re
import asyncio
import json
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
import yt_dlp
import aiohttp
import aiofiles
from shazamio import Shazam

# Bot tokeningizni bu yerga kiriting
BOT_TOKEN = "7590973597:AAHlUTNUywhZZwVpcLWADA_kV-50QkGYD_Q"

# Video va audio fayllar uchun papka
DOWNLOAD_PATH = "downloads"
os.makedirs(DOWNLOAD_PATH, exist_ok=True)

# Instagram uchun cookies fayli (agar mavjud bo'lsa)
COOKIES_FILE = "cookies.txt"


class SocialMediaBot:
    def __init__(self):
        self.session = None
        self.shazam = Shazam()

    async def get_session(self):
        """HTTP sessiya olish"""
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession()
        return self.session

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Bot boshlanganida xush kelibsiz xabari"""
        welcome_text = """
üé• <b>Ijtimoiy Tarmoq Video Yuklovchi Bot</b>

Salom! Men sizga quyidagi platformalardan video yuklashda yordam beraman:
‚Ä¢ YouTube
‚Ä¢ Instagram
‚Ä¢ TikTok
‚Ä¢ Facebook
‚Ä¢ Twitter
‚Ä¢ Reddit
‚Ä¢ Va 1000+ boshqa platformalar

üì± <b>Qanday foydalanish:</b>
1. Video linkini yuboring
2. Videoni yuklab olaman
3. "Musiqa" tugmasini bosib, videodagi musiqani topishingiz mumkin

Videoni yuborish uchun shunchaki linkni yuboring! üëá
        """
        await update.message.reply_text(welcome_text, parse_mode='HTML')

    async def download_video(self, url: str, chat_id: int) -> dict:
        """Videoni yuklab olish"""
        try:
            # chat_id ni papka nomi sifatida ishlatish orqali fayl nomini yanada moslashuvchan qilish
            user_download_path = os.path.join(DOWNLOAD_PATH, str(chat_id))
            os.makedirs(user_download_path, exist_ok=True)
            output_path = os.path.join(user_download_path, '%(title)s.%(ext)s')

            ydl_opts = {
                'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best', # More flexible format
                'outtmpl': output_path,
                'quiet': True,
                'no_warnings': True,
                'extract_audio': False,
                'max_filesize': 50 * 1024 * 1024,  # 50MB max
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
                'socket_timeout': 30,
                'retries': 10,
                'fragment_retries': 10,
            }
                'max_filesize': 50 * 1024 * 1024,  # 50MB max
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
                'socket_timeout': 30,
                'retries': 10,
                'fragment_retries': 10,
            }
                'max_filesize': 50 * 1024 * 1024,  # 50MB max
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
                'socket_timeout': 30,
                'retries': 10,
                'fragment_retries': 10,
            }
            if os.path.exists(COOKIES_FILE):
                ydl_opts['cookiefile'] = COOKIES_FILE

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                filename = ydl.prepare_filename(info)

                return {
                    'success': True,
                    'file_path': filename,
                    'title': info.get('title', 'Video'),
                    'duration': info.get('duration', 0),
                    'url': url
                }
        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def extract_audio(self, video_url: str, chat_id: int) -> str:
        """Videodan audio ajratib olish"""
        try:
            audio_path = f"{DOWNLOAD_PATH}/{chat_id}_audio.mp3"

            ydl_opts = {
                'format': 'bestaudio/best',
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
                'outtmpl': audio_path.replace('.mp3', ''),
                'quiet': True,
                'no_warnings': True,
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            }

            if os.path.exists(COOKIES_FILE):
                ydl_opts['cookiefile'] = COOKIES_FILE

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([video_url])

            return audio_path if os.path.exists(audio_path) else None
        except Exception as e:
            print(f"Audio ajratishda xato: {e}")
            return None

    async def recognize_music_audd(self, audio_path: str) -> dict:
        """AudD.io API orqali musiqani tanib olish (bepul)"""
        try:
            session = await self.get_session()

            # Audio faylni o'qish (faqat birinchi 10 soniya)
            url = 'https://api.audd.io/'

            async with aiofiles.open(audio_path, 'rb') as f:
                audio_data = await f.read()

            # Faqat birinchi 1MB yuborish (tezroq ishlash uchun)
            if len(audio_data) > 1024 * 1024:
                audio_data = audio_data[:1024 * 1024]

            data = aiohttp.FormData()
            data.add_field('file', audio_data, filename='audio.mp3')
            data.add_field('return', 'apple_music,spotify')

            async with session.post(url, data=data) as resp:
                result = await resp.json()

            if result.get('status') == 'success' and result.get('result'):
                track = result['result']
                return {
                    'success': True,
                    'title': track.get('title', 'Noma\'lum'),
                    'artist': track.get('artist', 'Noma\'lum ijrochi'),
                    'album': track.get('album', ''),
                    'release_date': track.get('release_date', ''),
                    'spotify_url': track.get('spotify', {}).get('external_urls', {}).get('spotify', ''),
                    'apple_music_url': track.get('apple_music', {}).get('url', ''),
                }
            return {'success': False, 'error': 'Musiqa topilmadi'}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def get_video_info(self, url: str) -> dict:
        """Video haqida ma'lumot olish (musiqa uchun)"""
        try:
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': False,
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            }

            if os.path.exists(COOKIES_FILE):
                ydl_opts['cookiefile'] = COOKIES_FILE

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

                # TikTok, Instagram va boshqa platformalarda musiqa ma'lumotlari
                music_info = {
                    'track': info.get('track') or info.get('alt_title'),
                    'artist': info.get('artist') or info.get('uploader') or info.get('creator'),
                    'album': info.get('album'),
                }

                return music_info
        except:
            return {}

    async def search_youtube_music(self, query: str, limit: int = 5) -> list:
        """YouTube dan musiqa qidirish"""
        try:
            ydl_opts = {
                'format': 'bestaudio/best',
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            }

            if os.path.exists(COOKIES_FILE):
                ydl_opts['cookiefile'] = COOKIES_FILE

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                search_query = f"ytsearch{limit}:{query}"
                info = ydl.extract_info(search_query, download=False)
                
                results = []
                for entry in info.get('entries', []):
                    results.append({
                        'id': entry.get('id'),
                        'title': entry.get('title'),
                        'url': f"https://www.youtube.com/watch?v={entry.get('id')}",
                        'duration': entry.get('duration'),
                    })
                return results
        except Exception as e:
            print(f"YouTube qidiruvda xato: {e}")
            return []

    def format_duration(self, seconds):
        """Davomiylikni formatlash (mm:ss)"""
        if not seconds: return "0:00"
        m, s = divmod(int(seconds), 60)
        return f"{m}:{s:02d}"

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Foydalanuvchi xabarini qayta ishlash"""
        message = update.message.text
        chat_id = update.message.chat_id

        # URL tekshirish
        url_pattern = re.compile(
            r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
        )

        if not url_pattern.match(message):
            await update.message.reply_text(
                "‚ùå Iltimos, to'g'ri video linkini yuboring!\n\n"
                "Masalan:\n"
                "‚Ä¢ https://www.youtube.com/watch?v=...\n"
                "‚Ä¢ https://www.tiktok.com/@user/video/...\n"
                "‚Ä¢ https://www.instagram.com/reel/..."
            )
            return

        # Yuklanmoqda xabari
        status_msg = await update.message.reply_text("‚è≥ Video yuklanmoqda...")

        # Videoni yuklab olish
        result = await self.download_video(message, chat_id)

        if not result['success']:
            await status_msg.edit_text(
                f"‚ùå Video yuklab olinmadi\n\n"
                f"Sabab: {result['error']}\n\n"
                f"üí° Iltimos, linkni tekshiring yoki boshqa video yuboring."
            )
            return

        # Videoni yuborish
        await status_msg.edit_text("üì§ Video yuborilmoqda...")

        try:
            # Musiqa tugmasi
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üéµ Musiqa", callback_data=f"music_{chat_id}")]
            ])

            file_size = os.path.getsize(result['file_path'])

            # Telegram limiti: 50MB
            if file_size > 50 * 1024 * 1024:
                await status_msg.edit_text(
                    f"‚ùå Video juda katta ({file_size / (1024 * 1024):.1f} MB)\n"
                    f"Telegram limiti: 50 MB\n\n"
                    f"üí° Qisqaroq video yuboring."
                )
                os.remove(result['file_path'])
                return

            # Video faylni yuborish
            with open(result['file_path'], 'rb') as video:
                await update.message.reply_video(
                    video=video,
                    caption=f"‚úÖ {result['title'][:200]}",
                    reply_markup=keyboard,
                    supports_streaming=True,
                    read_timeout=120,
                    write_timeout=120
                )

            # Video faylni yuborishdan so'ng darhol o'chirish
            if os.path.exists(result['file_path']):
                os.remove(result['file_path'])

            # Status xabarini o'chirish
            await status_msg.delete()

            # Video ma'lumotlarini saqlash (faqat URL)
            context.user_data[f'video_url_{chat_id}'] = result['url']

        except Exception as e:
            await status_msg.edit_text(f"‚ùå Video yuborishda xato: {str(e)}")
            if os.path.exists(result['file_path']):
                os.remove(result['file_path'])

    async def handle_music_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Musiqa tugmasi bosilganda"""
        query = update.callback_query
        # Answer immediately to prevent timeout
        await query.answer("üîç Musiqa qidirilmoqda...")

        chat_id = int(query.data.split('_')[1])
        video_url = context.user_data.get(f'video_url_{chat_id}')

        if not video_url:
            await query.message.reply_text("‚ùå Video topilmadi. Qayta yuklang.")
            return

        search_msg = await query.message.reply_text("üéµ Musiqa qidirilmoqda...")

        # Avval video metadata dan musiqa ma'lumotlarini olishga harakat qilish
        video_info = await self.get_video_info(video_url)

        if video_info.get('track') or video_info.get('artist'):
            response = "üéµ <b>Video ma'lumotlaridan topilgan musiqa:</b>\n\n"

            if video_info.get('track'):
                response += f"üé§ <b>Qo'shiq:</b> {video_info['track']}\n"
            if video_info.get('artist'):
                response += f"üë§ <b>Ijrochi:</b> {video_info['artist']}\n"
            if video_info.get('album'):
                response += f"üíø <b>Albom:</b> {video_info['album']}\n"

            await search_msg.edit_text(response, parse_mode='HTML')
        else:
            # Agar metadata yo'q bo'lsa, audio orqali qidirish
            await search_msg.edit_text("üéµ Audio ajratilmoqda...")

            audio_path = await self.extract_audio(video_url, chat_id)

            if not audio_path or not os.path.exists(audio_path):
                await search_msg.edit_text(
                    "‚ùå Audio ajratib bo'lmadi\n\n"
                    "üí° FFmpeg o'rnatilganligini tekshiring:\n"
                    "Linux: sudo apt install ffmpeg\n"
                    "Mac: brew install ffmpeg"
                )
                return

            await search_msg.edit_text("üîç Musiqa tanib olinmoqda...")

            # Shazam orqali musiqani tanish (AudD o'rniga eng yaxshisi)
            try:
                music_recognition = await self.shazam.recognize_song(audio_path)
                if music_recognition.get('track'):
                    track = music_recognition['track']
                    music_info = {
                        'success': True,
                        'title': track.get('title', 'Noma\'lum'),
                        'artist': track.get('subtitle', 'Noma\'lum ijrochi'),
                    }
                else:
                    music_info = {'success': False, 'error': 'Musiqa topilmadi'}
            except Exception as e:
                print(f"Shazam xatosi: {e}")
                music_info = await self.recognize_music_audd(audio_path)

            # Audio faylni o'chirish (recognition dan keyin)
            if os.path.exists(audio_path):
                os.remove(audio_path)

            if music_info['success']:
                search_query = f"{music_info['artist']} - {music_info['title']}"
                await search_msg.edit_text(f"üîç <b>{search_query}</b> qidirilmoqda...", parse_mode='HTML')
                
                results = await self.search_youtube_music(search_query)
                
                if results:
                    response = f"ÔøΩ <b>{music_info['artist']} ‚Äî {music_info['title']}</b>\n\n"
                    
                    buttons = []
                    row = []
                    
                    for i, res in enumerate(results, 1):
                        duration = self.format_duration(res['duration'])
                        response += f"{i}. {res['title']} <b>{duration}</b>\n"
                        row.append(InlineKeyboardButton(str(i), callback_data=f"sel_{chat_id}_{i-1}"))
                    
                    response += f"\n@utezbot orqali istagan musiqangizni tez va oson toping!"
                    
                    buttons.append([InlineKeyboardButton("üéû Video", url=video_url)])
                    buttons.append(row)
                    
                    keyboard = InlineKeyboardMarkup(buttons)
                    
                    # Natijalarni saqlash (callback uchun)
                    context.user_data[f'music_results_{chat_id}'] = results
                    
                    await search_msg.edit_text(response, parse_mode='HTML', reply_markup=keyboard)
                else:
                    await search_msg.edit_text("‚ùå Hech qanday musiqa topilmadi.")
            else:
                await search_msg.edit_text(
                    f"‚ùå Musiqa topilmadi\n\n"
                    f"Sabab: {music_info.get('error', 'Noma\'lum xato')}\n\n"
                    f"üí° Ba'zi videolarda musiqa aniqlanmasligi mumkin."
                )

            if os.path.exists(audio_path):
                os.remove(audio_path)

        # Ma'lumotlarni tozalash
        if f'video_url_{chat_id}' in context.user_data:
            del context.user_data[f'video_url_{chat_id}']

    async def handle_music_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ro'yxatdan musiqa tanlanganda"""
        query = update.callback_query
        await query.answer()

        data = query.data.split('_')
        chat_id = int(data[1])
        index = int(data[2])

        results = context.user_data.get(f'music_results_{chat_id}')
        if not results or index >= len(results):
            await query.message.reply_text("‚ùå Ma'lumotlar eskirgan. Qayta qidirib ko'ring.")
            return

        selected = results[index]
        status_msg = await query.message.reply_text(f"‚è≥ <b>{selected['title']}</b> yuklanmoqda...", parse_mode='HTML')

        try:
            audio_path = f"{DOWNLOAD_PATH}/{chat_id}_selected.mp3"
            
            ydl_opts = {
                'format': 'bestaudio/best',
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
                'outtmpl': audio_path.replace('.mp3', ''),
                'quiet': True,
                'no_warnings': True,
                'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            }

            if os.path.exists(COOKIES_FILE):
                ydl_opts['cookiefile'] = COOKIES_FILE

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([selected['url']])

            if os.path.exists(audio_path):
                await status_msg.edit_text("üì§ Musiqa yuborilmoqda...")
                
                with open(audio_path, 'rb') as audio:
                    await context.bot.send_audio(
                        chat_id=chat_id,
                        audio=audio,
                        title=selected['title'],
                        caption=f"‚úÖ {selected['title']}\n\n@utezbot orqali yuklab olindi",
                        read_timeout=120,
                        write_timeout=120
                    )
                
                await status_msg.delete()
                os.remove(audio_path)
            else:
                await status_msg.edit_text("‚ùå Yuklab olishda xato yuz berdi.")

        except Exception as e:
            await status_msg.edit_text(f"‚ùå Xato: {str(e)}")
            if os.path.exists(audio_path):
                os.remove(audio_path)

    async def cleanup(self):
        """Bot to'xtaganda tozalash"""
        if self.session and not self.session.closed:
            await self.session.close()


def main():
    """Botni ishga tushirish"""
    bot = SocialMediaBot()

    # Proxy sozlamalari (agar kerak bo'lsa)
    # PROXY_URL = "socks5://127.0.0.1:1080"  # Yoki http://proxy.example.com:8080

    # Application yaratish
    # Proxy bilan:
    # from telegram.request import HTTPXRequest
    # request = HTTPXRequest(proxy=PROXY_URL)
    # application = Application.builder().token(BOT_TOKEN).request(request).build()

    # Proxy siz:
    application = (
        Application.builder()
        .token(BOT_TOKEN)
        .connect_timeout(30)
        .read_timeout(30)
        .write_timeout(30)
        .pool_timeout(30)
        .get_updates_read_timeout(30)
        .build()
    )

    # Handlerlar qo'shish
    application.add_handler(CommandHandler("start", bot.start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message))
    application.add_handler(CallbackQueryHandler(bot.handle_music_button, pattern=r"^music_"))
    application.add_handler(CallbackQueryHandler(bot.handle_music_selection, pattern=r"^sel_"))

    # Botni ishga tushirish
    print("ü§ñ Bot ishga tushdi!")
    print("üì± Video linkini yuboring...")

    try:
        application.run_polling(
            allowed_updates=Update.ALL_TYPES,
            drop_pending_updates=True
        )
    finally:
        # Tozalash
        asyncio.run(bot.cleanup())


if __name__ == '__main__':
    main()